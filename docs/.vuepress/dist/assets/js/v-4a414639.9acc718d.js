(self.webpackChunkblog=self.webpackChunkblog||[]).push([[506],{134:(e,i,l)=>{"use strict";l.r(i),l.d(i,{data:()=>t});const t={key:"v-4a414639",path:"/arithmetic/recursion/",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"概念",slug:"概念",children:[{level:3,title:"重复计算",slug:"重复计算",children:[]}]}],filePathRelative:"arithmetic/recursion/index.md",git:{updatedTime:1626343007e3,contributors:[{name:"zhangyu2207",email:"zhangyu2207@yundasys.com",commits:1}]}}},3781:(e,i,l)=>{"use strict";l.r(i),l.d(i,{default:()=>a});const t=(0,l(6252).uE)('<h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><p>递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。</p><p><img src="/dulinyu-blog/arithmetic/fJgzFyM6WvXGOi7.png" alt="递归" title="递归"></p><p>你可能想知道如何实现调用自身的函数。诀窍在于，每当递归函数调用自身时，它都会将给定的问题拆解为子问题。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。</p><p>为了确保递归函数不会导致无限循环，它应具有以下属性：</p><ul><li>一个简单的基本案例 —— 能够不使用递归来产生答案的终止方案。</li><li>一组规则，也称作递推关系，可将所有其他情况拆分到基本案例。</li></ul><h3 id="重复计算" tabindex="-1"><a class="header-anchor" href="#重复计算" aria-hidden="true">#</a> 重复计算</h3><p>一些问题使用递归考虑，思路是非常清晰的，但是却不推荐使用递归，例如下面的几个问题：</p><ul><li>斐波拉契数列</li><li>跳台阶</li><li>矩形覆盖</li><li>这几个问题使用递归都有一个共同的缺点，那就是包含大量的重复计算，如果递归层次比较深的话，直接会导致 JS 进程崩溃。</li></ul><p><img src="/dulinyu-blog/arithmetic/fA3okFVIMlxS1Q6.jpg" alt="递归" title="递归"></p><p>你可以使用记忆化的方法来避免重复计算，即开辟一个额外空间来存储已经计算过的值，但是这样又会浪费一定的内存空间。因此上面的问题一般会使用动态规划求解。</p><blockquote><p>所以，在使用递归之前，一定要判断代码是否含有重复计算，如果有的话，不推荐使用递归。</p></blockquote><p>递归是一种思想，而非一个类型，很多经典算法都是以递归为基础，因此这里就不再给出更多问题。</p>',13),a={render:function(e,i){return t}}}}]);