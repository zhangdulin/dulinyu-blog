(self.webpackChunkblog=self.webpackChunkblog||[]).push([[452],{7758:(e,r,l)=>{"use strict";l.r(r),l.d(r,{data:()=>a});const a={key:"v-0af14385",path:"/arithmetic/dfsBfs/",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"广度优先和深度优先",slug:"广度优先和深度优先",children:[{level:3,title:"广度优先搜索",slug:"广度优先搜索",children:[]},{level:3,title:"深度优先搜索",slug:"深度优先搜索",children:[]}]}],filePathRelative:"arithmetic/dfsBfs/index.md",git:{updatedTime:1626343007e3,contributors:[{name:"zhangyu2207",email:"zhangyu2207@yundasys.com",commits:1}]}}},4881:(e,r,l)=>{"use strict";l.r(r),l.d(r,{default:()=>H});var a=l(6252);const n=(0,a.Wm)("h2",{id:"广度优先和深度优先",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#广度优先和深度优先","aria-hidden":"true"},"#"),(0,a.Uk)(" 广度优先和深度优先")],-1),t=(0,a.Wm)("h3",{id:"广度优先搜索",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#广度优先搜索","aria-hidden":"true"},"#"),(0,a.Uk)(" 广度优先搜索")],-1),i=(0,a.Wm)("p",null,"广度优先搜索（BFS）是一种遍历或搜索数据结构（如树或图）的算法，也可以在更抽象的场景中使用。",-1),m=(0,a.Wm)("p",null,"它的特点是越是接近根结点的结点将越早地遍历。",-1),d=(0,a.Wm)("p",null,"例如，我们可以使用 BFS 找到从起始结点到目标结点的路径，特别是最短路径。",-1),h=(0,a.Wm)("p",null,"在 BFS 中，结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出，所以广度优先搜索一般使用队列实现。",-1),u={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},W=(0,a.Uk)(" 从上到下打印二叉树"),o={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},f=(0,a.Uk)(" 单词接龙"),c={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},k=(0,a.Uk)(" 员工的重要性"),s={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},p=(0,a.Uk)(" 岛屿数量"),g=(0,a.Wm)("h3",{id:"深度优先搜索",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#深度优先搜索","aria-hidden":"true"},"#"),(0,a.Uk)(" 深度优先搜索")],-1),b=(0,a.Wm)("p",null,"和广度优先搜索一样，深度优先搜索（DFS）是用于在树/图中遍历/搜索的一种重要算法。",-1),y=(0,a.Wm)("p",null,"与 BFS 不同，更早访问的结点可能不是更靠近根结点的结点。因此，你在 DFS 中找到的第一条路径可能不是最短路径。",-1),U=(0,a.Wm)("p",null,[(0,a.Wm)("img",{src:"/dulinyu-blog/arithmetic/uNAkPfLY9HRjVQU.png",alt:"BFS&DFS",title:"深度优先搜索"})],-1),F=(0,a.Wm)("p",null,"在 DFS 中，结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出。所以深度优先搜索一般使用栈实现。",-1),S={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},_=(0,a.Uk)(" 二叉树的中序遍历"),B={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},v=(0,a.Uk)(" 路径总和"),x={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},D=(0,a.Uk)(" 课程表"),w={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},z=(0,a.Uk)(" 二叉树的中序遍历"),C={href:"/arithmetic/find/array.md",target:"_blank",rel:"noopener noreferrer"},j=(0,a.Uk)(" 岛屿数量"),H={render:function(e,r){const l=(0,a.up)("OutboundLink"),H=(0,a.up)("Gitalk");return(0,a.wg)(),(0,a.j4)(a.HY,null,[n,t,i,m,d,h,(0,a.Wm)("ul",null,[(0,a.Wm)("li",null,[(0,a.Wm)("a",u,[W,(0,a.Wm)(l)])]),(0,a.Wm)("li",null,[(0,a.Wm)("a",o,[f,(0,a.Wm)(l)])]),(0,a.Wm)("li",null,[(0,a.Wm)("a",c,[k,(0,a.Wm)(l)])]),(0,a.Wm)("li",null,[(0,a.Wm)("a",s,[p,(0,a.Wm)(l)])])]),g,b,y,U,F,(0,a.Wm)("ul",null,[(0,a.Wm)("li",null,[(0,a.Wm)("a",S,[_,(0,a.Wm)(l)])]),(0,a.Wm)("li",null,[(0,a.Wm)("a",B,[v,(0,a.Wm)(l)])]),(0,a.Wm)("li",null,[(0,a.Wm)("a",x,[D,(0,a.Wm)(l)])]),(0,a.Wm)("li",null,[(0,a.Wm)("a",w,[z,(0,a.Wm)(l)])]),(0,a.Wm)("li",null,[(0,a.Wm)("a",C,[j,(0,a.Wm)(l)])])]),(0,a.Wm)(H)],64)}}}}]);