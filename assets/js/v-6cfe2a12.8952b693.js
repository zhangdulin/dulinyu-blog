"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1440],{2861:(a,e,t)=>{t.r(e),t.d(e,{data:()=>r});const r={key:"v-6cfe2a12",path:"/javaScript/GoogleV8/list/p1.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"如何学习谷歌高性能 JavaScript 引擎V8？",slug:"如何学习谷歌高性能-javascript-引擎v8",children:[{level:3,title:"什么是 V8？",slug:"什么是-v8",children:[]},{level:3,title:"事件循环系统",slug:"事件循环系统",children:[]},{level:3,title:"垃圾回收机制",slug:"垃圾回收机制",children:[]}]}],filePathRelative:"javaScript/GoogleV8/list/p1.md",git:{updatedTime:1663811863e3,contributors:[]}}},286:(a,e,t)=>{t.r(e),t.d(e,{default:()=>c});var r=t(6252);const i=(0,r.uE)('<h2 id="如何学习谷歌高性能-javascript-引擎v8" tabindex="-1"><a class="header-anchor" href="#如何学习谷歌高性能-javascript-引擎v8" aria-hidden="true">#</a> 如何学习谷歌高性能 JavaScript 引擎V8？</h2><h3 id="什么是-v8" tabindex="-1"><a class="header-anchor" href="#什么是-v8" aria-hidden="true">#</a> 什么是 V8？</h3><p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。</p><p>编译流水线本身并不复杂，但是其中涉及到了很多技术，诸如 JIT、延迟解析、隐藏类、内联缓存等等。这些技术决定着一段 JavaScript 代码能否正常执行，以及代码的执行效率</p><p>比如 V8 中使用的隐藏类（Hide Class），这是将 JavaScript 中动态类型转换为静态类型的一种技术，可以消除动态类型的语言执行速度过慢的问题，如果你熟悉 V8 的工作机制，在你编写 JavaScript 时，就能充分利用好隐藏类这种强大的优化特性，写出更加高效的代码。</p><h3 id="事件循环系统" tabindex="-1"><a class="header-anchor" href="#事件循环系统" aria-hidden="true">#</a> 事件循环系统</h3><p>事件循环系统和 JavaScript 中的难点——异步编程特性紧密相关。我们知道，JavaScript 是单线程的，JavaScript 代码都是在一个线程上执行，如果同一时间发送了多个 JavaScript 执行的请求，就需要排队，也就是进行异步编程。</p><h3 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制" aria-hidden="true">#</a> 垃圾回收机制</h3><p>，JavaScript 是一种自动垃圾回收的语言，V8 在执行垃圾回收时，会占用主线程的资源，如果我们编写的程序频繁触发垃圾回收，那么无疑会阻塞主线程，这也是我们经常会遇到的一个问题。你需要知道 V8 是如何分配内存数据的，以及这些数据是如何被回收的，打通整个链路，建立完整的系统，当下次遇到内存问题时，就知道如何去排查了。</p>',9),l={},c=(0,t(3744).Z)(l,[["render",function(a,e){const t=(0,r.up)("Gitalk");return(0,r.wg)(),(0,r.iD)(r.HY,null,[i,(0,r.Wm)(t)],64)}]])}}]);