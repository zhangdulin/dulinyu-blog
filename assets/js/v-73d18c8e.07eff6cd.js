"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[2894],{2252:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-73d18c8e",path:"/javaScript/GoogleV8/list/p5.html",title:"",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"时间循环和垃圾回收",slug:"时间循环和垃圾回收",children:[{level:3,title:"消息队列：V8是怎么实现回调函数的？",slug:"消息队列-v8是怎么实现回调函数的",children:[]},{level:3,title:"V8是如何实现微任务的？",slug:"v8是如何实现微任务的",children:[]},{level:3,title:"V8是如何实现async/await的？",slug:"v8是如何实现async-await的",children:[]},{level:3,title:"V8的两个垃圾回收器是如何工作的？",slug:"v8的两个垃圾回收器是如何工作的",children:[]},{level:3,title:"V8是如何优化垃圾回收器执行效率的？",slug:"v8是如何优化垃圾回收器执行效率的",children:[]},{level:3,title:"几种常见内存问题的解决策略",slug:"几种常见内存问题的解决策略",children:[]}]}],filePathRelative:"javaScript/GoogleV8/list/p5.md",git:{updatedTime:166799611e4,contributors:[]}}},452:(n,s,a)=>{a.r(s),a.d(s,{default:()=>u});var e=a(6252);const p=a.p+"assets/img/b5c6a4cd613d262047a4339adb4eb8e1.08c76f25.jpg",t=a.p+"assets/img/1b0ea2180dd2406b988b424cc2933746.ca56e664.jpg",c=a.p+"assets/img/6e0508be2a2444cba8ade6230610f4f3.a2b613ed.jpg",l=a.p+"assets/img/be18e6dc6c93e761a37d50aed48f246f.c0367c06.jpg",o=a.p+"assets/img/b2894f2297a23a9d706d0517610deeeb.7838a966.jpg",r=(0,e.uE)('<h2 id="时间循环和垃圾回收" tabindex="-1"><a class="header-anchor" href="#时间循环和垃圾回收" aria-hidden="true">#</a> 时间循环和垃圾回收</h2><h3 id="消息队列-v8是怎么实现回调函数的" tabindex="-1"><a class="header-anchor" href="#消息队列-v8是怎么实现回调函数的" aria-hidden="true">#</a> 消息队列：V8是怎么实现回调函数的？</h3><p><img src="'+p+'" alt="V8 UI 线程的宏观架构" title="V8 UI 线程的宏观架构"> 今天我们介绍了 V8 是如何执行回调函数的。回调函数有两种类型：同步回调和异步回调，同步回调函数是在执行函数内部被执行的，</p><p>而异步回调函数是在执行函数外部被执行的。那么，搞清楚异步回调函数在什么时机被执行就非常关键了。为了理清楚这个问题，我们分析了通用 UI 线程宏观架构。UI 线程提供一个消息队列，并将待执行的事件添加到消息队列中，然后 UI 线程会不断循环地从消息队列中取出事件、执行事件。</p><p>关于异步回调，这里也有两种不同的类型，其典型代表是 setTimeout 和 XMLHttpRequest。setTimeout 的执行流程其实是比较简单的，在 setTimeout 函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数。</p><p>XMLHttpRequest 稍微复杂一点，因为下载过程需要放到单独的一个线程中去执行，所以执行 XMLHttpRequest.send 的时候，宿主会将实际请求转发给网络线程，然后 send 函数退出，主线程继续执行下面的任务。网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加进消息队列中，然后主线程从消息队列中取出回调事件，并执行回调函数。</p><h3 id="v8是如何实现微任务的" tabindex="-1"><a class="header-anchor" href="#v8是如何实现微任务的" aria-hidden="true">#</a> V8是如何实现微任务的？</h3><p>基于这套基础 UI 框架，JavaScript 又延伸出很多新的技术，其中应用最广泛的当属宏任务和微任务。 宏任务很简单，就是指消息队列中的等待被主线程执行的事件。 每个宏任务在执行时，V8 都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务。 微任务稍微复杂一点，其实你可以把微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景，那么微任务可以在实时性和效率之间做一个有效的权衡。另外使用微任务，可以改变我们现在的异步编程模型，使得我们可以使用同步形式的代码来编写异步调用。 <img src="'+t+'" alt="微任务" title="微任务"></p><p>理解微任务的执行时机，你只需要记住以下两点：</p><blockquote><p>首先，如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以执行微任务时，不会导致栈的无限扩张； 其次，和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也就意味着在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的。 不过，由于 V8 每次执行微任务时，都会退出当前 foo 函数的调用栈，所以这段代码是不会造成栈溢出的。</p></blockquote><h3 id="v8是如何实现async-await的" tabindex="-1"><a class="header-anchor" href="#v8是如何实现async-await的" aria-hidden="true">#</a> V8是如何实现async/await的？</h3><p>其实 async/await 技术背后的秘密就是 Promise 和生成器应用，往底层说，就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。 根据 MDN 定义，async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。 <img src="'+c+'" alt="异步编程的方案史" title="异步编程的方案史"></p><h3 id="v8的两个垃圾回收器是如何工作的" tabindex="-1"><a class="header-anchor" href="#v8的两个垃圾回收器是如何工作的" aria-hidden="true">#</a> V8的两个垃圾回收器是如何工作的？</h3><p>JavaScript 是一门自动垃圾回收的语言，也就是说，我们不需要去手动回收垃圾数据，这一切都交给 V8 的垃圾回收器来完成。V8 为了更高效地回收垃圾，引入了两个垃圾回收器， 目前 V8 采用了两个垃圾回收器，主垃圾回收器 -Major GC 和副垃圾回收器 -Minor GC (Scavenger)。V8 之所以使用了两个垃圾回收器，主要是受到了代际假说（The Generational Hypothesis）的影响。 代际假说是垃圾回收领域中一个重要的术语，它有以下两个特点：</p><blockquote><p>第一个是大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问； 第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。 其实这两个特点不仅仅适用于 JavaScript，同样适用于大多数的编程语言，如 Java、Python 等。</p></blockquote><h3 id="v8是如何优化垃圾回收器执行效率的" tabindex="-1"><a class="header-anchor" href="#v8是如何优化垃圾回收器执行效率的" aria-hidden="true">#</a> V8是如何优化垃圾回收器执行效率的？</h3><p>由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p><ul><li>增量回收 谓增量式垃圾回收，是指垃圾收集器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作，具体流程你可以参看下图： <img src="'+l+'" alt="增量回收" title="增量回收"></li></ul><p>V8 最开始的垃圾回收器有两个特点，第一个是垃圾回收在主线程上执行，第二个特点是一次执行一个完整的垃圾回收流程。</p><p>由于这两个原因，很容易造成主线程卡顿，所以 V8 采用了很多优化执行效率的方案。</p><ul><li>第一个方案是并行回收，在执行一个完整的垃圾回收过程中，垃圾回收器会使用多个辅助线程来并行执行垃圾回收。</li><li>第二个方案是增量式垃圾回收，垃圾回收器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作。</li><li>第三个方案是并发回收，回收线程在执行 JavaScript 的过程，辅助线程能够在后台完成的执行垃圾回收的操作。主垃圾回收器就综合采用了所有的方案，副垃圾回收器也采用了部分方案</li></ul><h3 id="几种常见内存问题的解决策略" tabindex="-1"><a class="header-anchor" href="#几种常见内存问题的解决策略" aria-hidden="true">#</a> 几种常见内存问题的解决策略</h3><p>Node 的体系架构 <img src="'+o+'" alt="Node 的体系架构" title="Node 的体系架构"> 内存问题至关重要，因为通过内存而造成的问题很容易被用户察觉。总的来说，内存问题可以定义为下面这三类：</p><ul><li>内存泄漏 (Memory leak)，它会导致页面的性能越来越差；</li><li>内存膨胀 (Memory bloat)，它会导致页面的性能会一直很差；</li><li>频繁垃圾回收，它会导致页面出现延迟或者经常暂停。</li></ul><p>优化防止内存泄露</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  \n    <span class="token keyword">var</span> temp_object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    temp_object<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span>\n    temp_object<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">2</span>\n    temp_object<span class="token punctuation">.</span>array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">200000</span><span class="token punctuation">)</span>\n    <span class="token doc-comment comment">/**\n    *   使用temp_object\n    */</span>\n   <span class="token keyword">let</span> closure <span class="token operator">=</span> temp_object<span class="token punctuation">.</span>x\n    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>closure<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><blockquote><p>内存膨胀和内存泄漏有一些差异，内存膨胀主要表现在程序员对内存管理的不科学，比如只需要 50M 内存就可以搞定的，有些程序员却花费了 500M 内存。额外使用过多的内存有可能是没有充分地利用好缓存，也有可能加载了一些不必要的资源。通常表现为内存在某一段时间内快速增长，然后达到一个平稳的峰值继续运行。</p></blockquote><blockquote><p>频繁使用大的临时变量，导致了新生代空间很快被装满，从而频繁触发垃圾回收。频繁的垃圾回收操作会让你感觉到页面卡顿。比如下面这段代码：</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>\n<span class="token keyword">function</span> <span class="token function">strToArray</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">const</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span>length\n  <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint16Array</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span>\n  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> arr<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n\n<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>\n  <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&#39;test V8 GC&#39;</span>\n  <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">1e5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">strToArray</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div>',29),i={},u=(0,a(3744).Z)(i,[["render",function(n,s){const a=(0,e.up)("Gitalk");return(0,e.wg)(),(0,e.iD)(e.HY,null,[r,(0,e.Wm)(a)],64)}]])}}]);